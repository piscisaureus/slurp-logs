{"nick":"AtumT","reason":"Quit: AtumT","date":"2019-01-14T00:30:32.457Z","type":"quit"}
{"nick":"Bakkot","message":"ljharb / zenparsing: I forget when I last pinged you about this, but, it would be good to get #1158 and #1137, or equivalents, in for 2019. 1158 needs updated wording but is waiting on 1137.","date":"2019-01-14T01:44:34.241Z","type":"message"}
{"nick":"gibson042","date":"2019-01-14T02:06:10.196Z","type":"join"}
{"nick":"gibson042","reason":"Quit: Leaving.","date":"2019-01-14T04:24:18.799Z","type":"quit"}
{"nick":"keith_miller","date":"2019-01-14T04:25:36.504Z","type":"join"}
{"nick":"ephemera_","reason":"Remote host closed the connection","date":"2019-01-14T04:55:01.504Z","type":"quit"}
{"nick":"ephemera_","date":"2019-01-14T04:56:15.417Z","type":"join"}
{"nick":"jmdyck","reason":"Remote host closed the connection","date":"2019-01-14T05:35:39.875Z","type":"quit"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T06:08:49.574Z","type":"quit"}
{"nick":"ljharb","message":"Bakkot: i'll add 1137 to the list for next week's meeting; things don't \"transition\" until after may tho, so it's still in bterlson's queue atm","date":"2019-01-14T06:11:20.613Z","type":"message"}
{"nick":"devsnek","message":"have y'all seen that cherow got a makeover","date":"2019-01-14T06:14:35.200Z","type":"message"}
{"nick":"devsnek","message":"(https://github.com/cherow/cherow btw)","date":"2019-01-14T06:14:43.739Z","type":"message"}
{"nick":"ljharb","message":"O.o what is cherow","date":"2019-01-14T06:15:48.358Z","type":"message"}
{"nick":"TimothyGu","message":"a better acorn that passes test262","date":"2019-01-14T06:16:05.385Z","type":"message"}
{"nick":"TimothyGu","message":"just like how acorn was a better esprima","date":"2019-01-14T06:16:19.584Z","type":"message"}
{"nick":"ljharb","message":"if it's better, has there been an attempt to get eslint and/or babel to use it?","date":"2019-01-14T06:16:28.868Z","type":"message"}
{"nick":"devsnek","message":"its still in development","date":"2019-01-14T06:16:34.779Z","type":"message"}
{"nick":"devsnek","message":"two months ago it barely passed es5","date":"2019-01-14T06:16:39.130Z","type":"message"}
{"nick":"devsnek","message":"but its estree compatible so should be good to slide into anything","date":"2019-01-14T06:17:20.038Z","type":"message"}
{"nick":"ljharb","message":"ah k","date":"2019-01-14T06:18:34.514Z","type":"message"}
{"nick":"ljharb","message":"slide it into eslint core then :-p","date":"2019-01-14T06:18:42.740Z","type":"message"}
{"nick":"devsnek","message":"i've become really surprised with how loose all the big parsers are (acorn, babel, etc)","date":"2019-01-14T06:21:20.156Z","type":"message"}
{"nick":"devsnek","message":"they all miss a lot of context and early errors","date":"2019-01-14T06:21:28.739Z","type":"message"}
{"nick":"TimothyGu","message":"in case of Acorn: https://github.com/acornjs/acorn/issues/created_by/TimothyGu","date":"2019-01-14T06:21:57.368Z","type":"message"}
{"nick":"Bakkot","message":"babel has much more work because of all the syntax extensions it has to do","date":"2019-01-14T06:27:49.501Z","type":"message"}
{"nick":"keith_miller","date":"2019-01-14T06:28:03.093Z","type":"join"}
{"nick":"Bakkot","message":"a while back, as part of test262-parser-tests, I started a project to run all the parsers against it and file bugs","date":"2019-01-14T06:28:10.203Z","type":"message"}
{"nick":"Bakkot","message":"but there were so many and I never got back to it","date":"2019-01-14T06:28:30.423Z","type":"message"}
{"nick":"devsnek","message":"its kinda weird how none of them actually run against test262 though","date":"2019-01-14T06:29:40.364Z","type":"message"}
{"nick":"Bakkot","message":"shift does!","date":"2019-01-14T06:29:44.795Z","type":"message"}
{"nick":"Bakkot","message":"https://github.com/shapesecurity/shift-parser-js/tree/8add44f4289b215eac555412d75547f5d2137133/test/test262","date":"2019-01-14T06:29:54.611Z","type":"message"}
{"nick":"devsnek","message":"ok none of the ones with es2019","date":"2019-01-14T06:30:07.314Z","type":"message"}
{"nick":"Bakkot","message":"es2019 isn't a thing yet","date":"2019-01-14T06:30:23.473Z","type":"message"}
{"nick":"devsnek","message":"es2019 draft","date":"2019-01-14T06:30:31.423Z","type":"message"}
{"nick":"devsnek","message":"tc39.github.io is the only good source of truth","date":"2019-01-14T06:31:04.975Z","type":"message"}
{"nick":"Bakkot","message":"we track releases of the spec because AST changes are breaking, and it makes sense to bundle those","date":"2019-01-14T06:31:52.517Z","type":"message"}
{"nick":"devsnek","message":"is shift a cst","date":"2019-01-14T06:32:27.104Z","type":"message"}
{"nick":"ljharb","message":"why are ast changes breaking? aren't they additions?","date":"2019-01-14T06:33:01.035Z","type":"message"}
{"nick":"Bakkot","message":"no, though it has an API which lets you query the location information for an AST node and also get comments with locations","date":"2019-01-14T06:33:01.310Z","type":"message"}
{"nick":"devsnek","message":"yeah if its an ast i don't think there would be breaking changes","date":"2019-01-14T06:33:25.743Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: if I have something which consumes an AST and assumes that e.g. `catch`'s binding is necessarily there, that will break if that stops being the case","date":"2019-01-14T06:33:33.538Z","type":"message"}
{"nick":"devsnek","message":"oh yeah i guess that broke eslint","date":"2019-01-14T06:33:46.279Z","type":"message"}
{"nick":"Bakkot","message":"yes it did!","date":"2019-01-14T06:33:52.654Z","type":"message"}
{"nick":"Bakkot","message":"though this is more obvious in the Java version, where the AST nodes are represented by Java types which of course must match precisely","date":"2019-01-14T06:34:00.278Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: ah, true. i suppose if the edition year were an option it'd be fine","date":"2019-01-14T06:34:11.445Z","type":"message"}
{"nick":"Bakkot","message":"we just publish new major versions /shrug","date":"2019-01-14T06:34:27.166Z","type":"message"}
{"nick":"devsnek","message":"oh yeah edition year","date":"2019-01-14T06:35:04.946Z","type":"message"}
{"nick":"devsnek","message":"why did eslint break again","date":"2019-01-14T06:35:15.224Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: seems unfortunate, can't look at multiple editions at once","date":"2019-01-14T06:35:15.483Z","type":"message"}
{"nick":"Bakkot","message":"I think npm will let you depend on multiple versions of a package, these days","date":"2019-01-14T06:35:47.150Z","type":"message"}
{"nick":"devsnek","message":"oh you can add a custom parser to eslint","date":"2019-01-14T06:35:55.887Z","type":"message"}
{"nick":"Bakkot","message":"also though why would you want that","date":"2019-01-14T06:35:59.790Z","type":"message"}
{"nick":"devsnek","message":"so it would have been people with babel-eslint","date":"2019-01-14T06:36:01.187Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: it won't","date":"2019-01-14T06:36:55.207Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: not at the top level","date":"2019-01-14T06:36:58.110Z","type":"message"}
{"nick":"ljharb","message":"you'd want that if you wanted to provide a configuration option to your consumers and have shift as a dep - like eslint, babel, or every other use case for a parser so far :-)","date":"2019-01-14T06:37:28.007Z","type":"message"}
{"nick":"ljharb","message":"why wouldn't you want that?","date":"2019-01-14T06:37:52.883Z","type":"message"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T06:39:17.906Z","type":"quit"}
{"nick":"Bakkot","message":"Maintanence burden, mainly.","date":"2019-01-14T06:39:19.235Z","type":"message"}
{"nick":"ljharb","message":"well yeah that's why you wouldn't want it, but why wouldn't every user want it","date":"2019-01-14T06:39:32.618Z","type":"message"}
{"nick":"ljharb","message":"i mean, specifically, no extant tool in the ecosystem could switch to shift without it - so it seems a pretty important thing to have if adoption is a goal","date":"2019-01-14T06:40:09.354Z","type":"message"}
{"nick":"Bakkot","message":"because config = bad, just give me the thing which parses the most programs, generally speaking","date":"2019-01-14T06:40:10.018Z","type":"message"}
{"nick":"Bakkot","message":"if we made breaking changes to old parses, which we do occasionally in obscure unicode things but not otherwise, I'd understand","date":"2019-01-14T06:40:34.797Z","type":"message"}
{"nick":"ljharb","message":"config isn't bad, as long as the defaults are reasonable, config id very very good","date":"2019-01-14T06:40:37.380Z","type":"message"}
{"nick":"Bakkot","message":"eh, I mean, I don't want to make absolutist statements, but it certainly is not a universal good","date":"2019-01-14T06:41:11.625Z","type":"message"}
{"nick":"ljharb","message":"nor a universal bad","date":"2019-01-14T06:41:17.516Z","type":"message"}
{"nick":"Bakkot","message":"I think one of the best things prettier has done for the ecosystem is push back on config options","date":"2019-01-14T06:41:26.075Z","type":"message"}
{"nick":"Bakkot","message":"anyway, no, adoption isn't really that much of a goal, at least not into existing projects like eslint","date":"2019-01-14T06:41:55.093Z","type":"message"}
{"nick":"ljharb","message":"and the lack of configs is why its adoption is as low as it is, and prettier has added way more config options than its creator ideologically promised","date":"2019-01-14T06:41:56.053Z","type":"message"}
{"nick":"ljharb","message":"gotcha","date":"2019-01-14T06:41:58.931Z","type":"message"}
{"nick":"devsnek","message":"acorn defaults to es5.1 :(","date":"2019-01-14T06:42:11.069Z","type":"message"}
{"nick":"Bakkot","message":"main goal is providing a correct parser with a sane AST for ourselves and anyone else who wants that, like the binast people","date":"2019-01-14T06:42:27.967Z","type":"message"}
{"nick":"Bakkot","message":"also reducer-style transforms, which are _so_ much nicer than visitors, jeeze","date":"2019-01-14T06:43:03.316Z","type":"message"}
{"nick":"ljharb","message":"devsnek: still the best default, based on most browser support targets","date":"2019-01-14T06:43:04.709Z","type":"message"}
{"nick":"Bakkot","message":"speaking of, just updated the website! http://shift-ast.org/reducer.html","date":"2019-01-14T06:43:14.026Z","type":"message"}
{"nick":"devsnek","message":"ljharb: parsers should support all the way up","date":"2019-01-14T06:43:15.993Z","type":"message"}
{"nick":"devsnek","message":"if acorn generated code i would agree with you","date":"2019-01-14T06:43:23.581Z","type":"message"}
{"nick":"ljharb","message":"devsnek: i agree that it should be possible, but i think es5 is still the proper default, and will be for awhile","date":"2019-01-14T06:43:44.726Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: not sure why \"this JS is targeted for untransformed execution on large companys' browser support targets\" is a good assumption","date":"2019-01-14T06:43:55.790Z","type":"message"}
{"nick":"devsnek","message":"reducer is cool","date":"2019-01-14T06:44:15.260Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: it's the safest","date":"2019-01-14T06:44:47.864Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: because with transforms and old code, it still works. with a default of \"modern\" and no transforms, it breaks.","date":"2019-01-14T06:45:19.835Z","type":"message"}
{"nick":"ljharb","message":"(for users of old browsers, which are still plentiful)","date":"2019-01-14T06:45:29.166Z","type":"message"}
{"nick":"Bakkot","message":"were that the goal it should also refuse programs which parse incorrectly on browers with nontrivial adoption, which I think it absolutely should not do","date":"2019-01-14T06:45:51.691Z","type":"message"}
{"nick":"Bakkot","message":"if that's what you want, write a rule for it","date":"2019-01-14T06:45:57.067Z","type":"message"}
{"nick":"ljharb","message":"tbh i think eslint should do that by default. are you aware of any patterns it parses that fail on browsers?","date":"2019-01-14T06:46:33.222Z","type":"message"}
{"nick":"ljharb","message":"imo the default should be what will maximize \"where it works\"","date":"2019-01-14T06:46:49.363Z","type":"message"}
{"nick":"ljharb","message":"anything that restricts where it can work should be opt-in","date":"2019-01-14T06:47:00.662Z","type":"message"}
{"nick":"ljharb","message":"that doesn't mean the defaults have to work everywhere, ofc.","date":"2019-01-14T06:47:11.012Z","type":"message"}
{"nick":"devsnek","message":"as long as the parser doesn't think `let let = class let {}` is valid","date":"2019-01-14T06:47:23.364Z","type":"message"}
{"nick":"devsnek","message":"i'm happy","date":"2019-01-14T06:47:25.819Z","type":"message"}
{"nick":"Bakkot","message":"({゛: \"゛\"}) failed on safari relatively recently","date":"2019-01-14T06:48:22.560Z","type":"message"}
{"nick":"Bakkot","message":"`!await test()` too","date":"2019-01-14T06:48:43.212Z","type":"message"}
{"nick":"ljharb","message":"then it shouldn't be permitted by eslint nor outputted by babel ¯\\_(ツ)_/¯","date":"2019-01-14T06:48:44.287Z","type":"message"}
{"nick":"Bakkot","message":"there's also a billion comment-parsing bugs old browsers, esp. re: html comments","date":"2019-01-14T06:49:06.912Z","type":"message"}
{"nick":"ljharb","message":"academic correctness isn't important with actual workflow tools; actual correctness is","date":"2019-01-14T06:49:07.164Z","type":"message"}
{"nick":"devsnek","message":"omg that object literal is evil","date":"2019-01-14T06:49:37.858Z","type":"message"}
{"nick":"devsnek","message":"why is that a valid identifier","date":"2019-01-14T06:49:44.200Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: your assumption is that the thing people want from eslint is that code run through it should work on browsers","date":"2019-01-14T06:49:59.757Z","type":"message"}
{"nick":"Bakkot","message":"but, I claim, that is very far from the majority use case","date":"2019-01-14T06:50:10.772Z","type":"message"}
{"nick":"ljharb","message":"i can't conceive of what other use case there is","date":"2019-01-14T06:50:36.658Z","type":"message"}
{"nick":"ljharb","message":"the point is to maximize correctness at later runtime","date":"2019-01-14T06:50:46.788Z","type":"message"}
{"nick":"devsnek","message":"i hear there's this cool thing called node.js","date":"2019-01-14T06:51:09.927Z","type":"message"}
{"nick":"devsnek","message":"which runs code on the server","date":"2019-01-14T06:51:13.012Z","type":"message"}
{"nick":"devsnek","message":"and that it supports like `const` and `class` and stuff","date":"2019-01-14T06:51:28.970Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: more things in heaven and earth etc","date":"2019-01-14T06:51:30.090Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: sure, but what use cases do you think people run eslint for that aren't maximizing runtime correctness?","date":"2019-01-14T06:52:27.788Z","type":"message"}
{"nick":"ljharb","message":"devsnek: ok well, implementations, not just browsers","date":"2019-01-14T06:52:38.921Z","type":"message"}
{"nick":"Bakkot","message":"maximizing correctness after being run through babel and/or uglify","date":"2019-01-14T06:52:42.831Z","type":"message"}
{"nick":"devsnek","message":"Bakkot: i disagree with your usage of that quotation","date":"2019-01-14T06:52:44.397Z","type":"message"}
{"nick":"Bakkot","message":"also some style stuff","date":"2019-01-14T06:52:49.852Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: O.o ok well, running eslint on compiler output is in *no way* a common use case, for one","date":"2019-01-14T06:53:04.489Z","type":"message"}
{"nick":"Bakkot","message":"sorry, no, the other way around:","date":"2019-01-14T06:53:14.546Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: and \"style stuff\", sure, but that overlaps","date":"2019-01-14T06:53:16.278Z","type":"message"}
{"nick":"Bakkot","message":"maximizing correctness of A after A is run through babel","date":"2019-01-14T06:53:36.087Z","type":"message"}
{"nick":"Bakkot","message":"not maximizing correctness of the output of babel on A","date":"2019-01-14T06:53:50.200Z","type":"message"}
{"nick":"ljharb","message":"i agree that babel/uglify/etc output is what actually needs to work, but the presumption is that you can eslint your input, and those tools won't output things that break","date":"2019-01-14T06:53:54.967Z","type":"message"}
{"nick":"ljharb","message":"in no way is it common to run eslint on any code but the code you author (what gets sent to babel)","date":"2019-01-14T06:54:18.942Z","type":"message"}
{"nick":"rkirsling","message":"^ yeah that would be wacky","date":"2019-01-14T06:54:35.911Z","type":"message"}
{"nick":"Bakkot","message":"I didn't mean to imply people were running babel on code comming out of babel","date":"2019-01-14T06:54:36.065Z","type":"message"}
{"nick":"Bakkot","message":"just the opposite","date":"2019-01-14T06:54:37.855Z","type":"message"}
{"nick":"ljharb","message":"i'm sure it's done, but basically nobody actually runs eslint on babel output. if you don't trust babel implicitly, don't use it","date":"2019-01-14T06:54:38.616Z","type":"message"}
{"nick":"ljharb","message":"once you put your code into a tool, you never run anything on it after that, typically","date":"2019-01-14T06:54:54.287Z","type":"message"}
{"nick":"ljharb","message":"babel, uglify, webpack, etc","date":"2019-01-14T06:55:00.632Z","type":"message"}
{"nick":"ljharb","message":"you just implicitly trust irt","date":"2019-01-14T06:55:03.946Z","type":"message"}
{"nick":"ljharb","message":"*it","date":"2019-01-14T06:55:06.103Z","type":"message"}
{"nick":"Bakkot","message":"yes, I know, that is not a point of disagreement","date":"2019-01-14T06:55:07.190Z","type":"message"}
{"nick":"Bakkot","message":"my point is that eslint etc should assume their target is those tools, not browsers","date":"2019-01-14T06:55:35.069Z","type":"message"}
{"nick":"ljharb","message":"ahhh","date":"2019-01-14T06:55:38.391Z","type":"message"}
{"nick":"ljharb","message":"ok sure, perhaps","date":"2019-01-14T06:55:41.427Z","type":"message"}
{"nick":"ljharb","message":"but then the \"no build process\" zealots will pop up","date":"2019-01-14T06:55:47.629Z","type":"message"}
{"nick":"ljharb","message":"and even tho i'm not one, i'd argue that the safe default is not to assume someone is using those tools","date":"2019-01-14T06:56:02.730Z","type":"message"}
{"nick":"ljharb","message":"since there are plenty of people that aren't","date":"2019-01-14T06:56:07.464Z","type":"message"}
{"nick":"Bakkot","message":"\"not to assume someone is using those tools and also that they are intending to target IE9\"","date":"2019-01-14T06:56:21.888Z","type":"message"}
{"nick":"Bakkot","message":"I think this is mostly a disagreement about what \"safe\" means.","date":"2019-01-14T06:56:30.416Z","type":"message"}
{"nick":"ljharb","message":"without explicit info, the safe thing is to assume someone is targeting every browser currently used by anyone","date":"2019-01-14T06:56:50.441Z","type":"message"}
{"nick":"ljharb","message":"IE 6, eg","date":"2019-01-14T06:56:57.354Z","type":"message"}
{"nick":"ljharb","message":"it's reasonable to pick an arbitrary cutoff, tho, and by many metrics that would still include IE 9 for sure, and possibly even IE 8","date":"2019-01-14T06:57:23.800Z","type":"message"}
{"nick":"Bakkot","message":"ok, I guess it is also a disagreement about the extent to which that sense of \"safe\" is a good default for a tool, as opposed to \"useful\"","date":"2019-01-14T06:57:26.424Z","type":"message"}
{"nick":"ljharb","message":"\"works\" is the most useful","date":"2019-01-14T06:57:37.069Z","type":"message"}
{"nick":"ljharb","message":"but sure, those indeed might be points of disagreement :-)","date":"2019-01-14T06:57:54.797Z","type":"message"}
{"nick":"Bakkot","message":"for me, \"eslint works\" means \"eslint will run the linting rules\"","date":"2019-01-14T06:58:03.549Z","type":"message"}
{"nick":"Bakkot","message":"since that is what I want eslint to do; that is how I keep my code correct","date":"2019-01-14T06:58:23.705Z","type":"message"}
{"nick":"devsnek","message":"to me, eslint should consider all the valid js as valid js unless you limit it","date":"2019-01-14T06:58:38.628Z","type":"message"}
{"nick":"Bakkot","message":"if it refuses to parse a valid thing, it does not work","date":"2019-01-14T06:58:51.254Z","type":"message"}
{"nick":"Bakkot","message":"if I want it to say a thing is bad, that is what _its rules_ are for, not the parser which runs before the rules","date":"2019-01-14T06:59:14.635Z","type":"message"}
{"nick":"devsnek","message":"yep","date":"2019-01-14T06:59:24.814Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: what defines \"valid\" tho","date":"2019-01-14T06:59:45.932Z","type":"message"}
{"nick":"ljharb","message":"if it's \"the spec\" then i'd point you to the overflowing \"web reality\" label on ecma262","date":"2019-01-14T07:00:06.437Z","type":"message"}
{"nick":"devsnek","message":"i'd say engines have a lot of bugs","date":"2019-01-14T07:00:31.315Z","type":"message"}
{"nick":"Bakkot","message":"the whole point of having a spec is to have a thing which tools can agree on as the single authority","date":"2019-01-14T07:00:37.701Z","type":"message"}
{"nick":"devsnek","message":"and the spec has a lot of bugs","date":"2019-01-14T07:00:42.407Z","type":"message"}
{"nick":"Bakkot","message":"\"web reality\" label doesn't have too many parsing things in it, IIRC, outside of some B33 bullshit and the `if (false) f() = 0` thing","date":"2019-01-14T07:00:58.061Z","type":"message"}
{"nick":"ljharb","message":"fair","date":"2019-01-14T07:01:06.632Z","type":"message"}
{"nick":"devsnek","message":"and a random subset of those things is what should work","date":"2019-01-14T07:01:14.778Z","type":"message"}
{"nick":"devsnek","message":"leaning towards sane behaviour over engine bugs","date":"2019-01-14T07:01:25.351Z","type":"message"}
{"nick":"ljharb","message":"but in practice the useful thing to consider \"valid\" is \"what *actually* works\", not \"what a spec says\" - it's just hopeful that those two agree","date":"2019-01-14T07:01:34.863Z","type":"message"}
{"nick":"devsnek","message":"like function names","date":"2019-01-14T07:01:58.538Z","type":"message"}
{"nick":"devsnek","message":"bad enough that Function.prototype has name as the empty string","date":"2019-01-14T07:02:05.779Z","type":"message"}
{"nick":"Bakkot","message":"I think for a tool like eslint the right thing to consider \"valid\" is \"what a spec says\", and add rules which will error for valid inputs which are likely to run incorrectly on bugs","date":"2019-01-14T07:02:13.924Z","type":"message"}
{"nick":"Bakkot","message":"*incorrectly on browsers because of bugs","date":"2019-01-14T07:02:24.337Z","type":"message"}
{"nick":"devsnek","message":"but then engines go around putting empty strings on all the anonymous functions 😥","date":"2019-01-14T07:02:26.028Z","type":"message"}
{"nick":"Bakkot","message":"\"have rules which will error for valid inputs which are likely to have bugs\" is after all the point of eslint","date":"2019-01-14T07:02:49.567Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: as long as there's a trivial way to configure that, then it's more of a bikeshed about the defaults","date":"2019-01-14T07:02:58.412Z","type":"message"}
{"nick":"Bakkot","message":"well, yes.","date":"2019-01-14T07:03:10.578Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: but i'd still prefer that with no config, the only allowed code is what will work. the spec is pedantry that isn't useful to most.","date":"2019-01-14T07:03:18.878Z","type":"message"}
{"nick":"Bakkot","message":"that really really seems wrong.","date":"2019-01-14T07:04:01.517Z","type":"message"}
{"nick":"ljharb","message":"why?","date":"2019-01-14T07:04:16.234Z","type":"message"}
{"nick":"Bakkot","message":"that is enforcing a rule at the wrong level.","date":"2019-01-14T07:04:19.648Z","type":"message"}
{"nick":"ljharb","message":"why would the majority of users care about that distinction tho?","date":"2019-01-14T07:04:36.203Z","type":"message"}
{"nick":"devsnek","message":"eslint doesn't know if you're targeting browsers or node or deno or mongoose","date":"2019-01-14T07:04:47.630Z","type":"message"}
{"nick":"Bakkot","message":"because the majority of users do not actually care about that rule","date":"2019-01-14T07:04:58.869Z","type":"message"}
{"nick":"devsnek","message":"so it should just consider all the valid js as valid","date":"2019-01-14T07:05:01.044Z","type":"message"}
{"nick":"ljharb","message":"right. so the safe thing to do is to only allow the things that work on all of them as valid. not any of them.","date":"2019-01-14T07:05:09.177Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: i guess that's where we disagree","date":"2019-01-14T07:05:14.819Z","type":"message"}
{"nick":"Bakkot","message":"specifically, the rule \"will be valid syntax on at least 98% of browsers\" is not a rule the vast majority of users care to enforce","date":"2019-01-14T07:05:18.568Z","type":"message"}
{"nick":"devsnek","message":"lol","date":"2019-01-14T07:05:18.722Z","type":"message"}
{"nick":"Bakkot","message":"because they intend to run through other tools downstream of eslint","date":"2019-01-14T07:05:26.009Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: i think what the majority of users don't care about is \"the spec\"","date":"2019-01-14T07:05:26.830Z","type":"message"}
{"nick":"ljharb","message":"Bakkot: plenty of people don't use babel","date":"2019-01-14T07:05:35.342Z","type":"message"}
{"nick":"devsnek","message":"i think most humans writing js go by mdn","date":"2019-01-14T07:05:53.442Z","type":"message"}
{"nick":"Bakkot","message":"sure, but a majority? of those who a.) care about support for old browsers and also use eslint?","date":"2019-01-14T07:05:55.096Z","type":"message"}
{"nick":"Bakkot","message":"\"*and also b.) use eslint\"; it is getting late, forgive my typos","date":"2019-01-14T07:06:14.111Z","type":"message"}
{"nick":"ljharb","message":"whether they actively care about old browsers isn't relevant","date":"2019-01-14T07:06:34.034Z","type":"message"}
{"nick":"ljharb","message":"that's the point. they should have to care about *breaking* them to break them","date":"2019-01-14T07:06:42.759Z","type":"message"}
{"nick":"ljharb","message":"the default should be to support them","date":"2019-01-14T07:06:47.165Z","type":"message"}
{"nick":"Bakkot","message":"that's a problem you have with users of the tools, not the tools they're using","date":"2019-01-14T07:07:14.900Z","type":"message"}
{"nick":"Bakkot","message":"I do not think eslint ought to enforce that preference on all of its users by default","date":"2019-01-14T07:07:37.271Z","type":"message"}
{"nick":"ljharb","message":"and the tools are working best when they can fix their users' problems :-)","date":"2019-01-14T07:07:39.451Z","type":"message"}
{"nick":"Bakkot","message":"that is a very reasonable rule to enforce, as a configurable rule; it is not a very reasonable default","date":"2019-01-14T07:07:48.489Z","type":"message"}
{"nick":"ljharb","message":"(note that i think we agree that regardless of the default, all of this should be configurable)","date":"2019-01-14T07:07:54.927Z","type":"message"}
{"nick":"ljharb","message":"i think \"breaking a website for any human being that's avoidable\" is not a reasonable default","date":"2019-01-14T07:08:16.541Z","type":"message"}
{"nick":"ljharb","message":"a single user is a person, and a site should work for them by default","date":"2019-01-14T07:08:25.701Z","type":"message"}
{"nick":"devsnek","message":"why's your parse rule only got 98% then","date":"2019-01-14T07:08:50.196Z","type":"message"}
{"nick":"Bakkot","message":"again, that is something you should take up with the users of the tools; the tools themselves should be agnostic to that position","date":"2019-01-14T07:08:53.292Z","type":"message"}
{"nick":"ljharb","message":"i think that's where we disagree","date":"2019-01-14T07:09:27.144Z","type":"message"}
{"nick":"ljharb","message":"and i think it's strange to claim tools should be agnostic while also claiming config is bag","date":"2019-01-14T07:09:42.543Z","type":"message"}
{"nick":"ljharb","message":"agnostic tools allow every single facet to be configured :-)","date":"2019-01-14T07:09:53.101Z","type":"message"}
{"nick":"Bakkot","message":"anyway, also I wouldn't want to configure the parser it uses, except to additionally support non-spec things if I wanted to opt in to those: I would want it to _accept_ those programs and then _emit errors because of rules run against them_.","date":"2019-01-14T07:09:54.632Z","type":"message"}
{"nick":"Bakkot","message":"I don't think eslint having config for the rules it runs is bad, to be clear","date":"2019-01-14T07:10:30.866Z","type":"message"}
{"nick":"Bakkot","message":"I think having config for things users shouldn't care about is bad","date":"2019-01-14T07:10:42.036Z","type":"message"}
{"nick":"Bakkot","message":"e.g. it should not have config for \"what es version does the parser support\"; it should have config for \"do you want a rule which will error for syntax from es2015 and later\"","date":"2019-01-14T07:11:14.094Z","type":"message"}
{"nick":"Bakkot","message":"but that should be a _rule_, exactly like all other rules","date":"2019-01-14T07:11:33.097Z","type":"message"}
{"nick":"Bakkot","message":"because its intent is to catch correctness issues under a particular definition of correctness, exactly like all other rules","date":"2019-01-14T07:12:02.477Z","type":"message"}
{"nick":"ljharb","message":"users don't care about the spec year","date":"2019-01-14T07:12:05.471Z","type":"message"}
{"nick":"ljharb","message":"they care about their supported environments","date":"2019-01-14T07:12:13.301Z","type":"message"}
{"nick":"Bakkot","message":"s/es2015/IE8/","date":"2019-01-14T07:12:15.333Z","type":"message"}
{"nick":"ljharb","message":"sure, so like, babel-preset-env","date":"2019-01-14T07:12:24.731Z","type":"message"}
{"nick":"ljharb","message":"and absent targets, i'm suggesting a broad default. perhaps it could require targets, and then no default would be needed","date":"2019-01-14T07:12:42.367Z","type":"message"}
{"nick":"ljharb","message":"but virtually nobody cares about \"es2015\"; they care about \"X target envs\", modulo maybe running through specific tools","date":"2019-01-14T07:13:13.354Z","type":"message"}
{"nick":"Bakkot","message":"\"broad\" should be wrt the input programs, so it can run rules on as many programs as it can.","date":"2019-01-14T07:13:31.881Z","type":"message"}
{"nick":"Bakkot","message":"if users don't care about the spec year, surely the parser should not be configured by spec year?","date":"2019-01-14T07:13:47.828Z","type":"message"}
{"nick":"ljharb","message":"i agree","date":"2019-01-14T07:13:53.105Z","type":"message"}
{"nick":"Bakkot","message":"or, indeed, configured at all","date":"2019-01-14T07:13:53.454Z","type":"message"}
{"nick":"ljharb","message":"it should be configured by targets","date":"2019-01-14T07:14:00.039Z","type":"message"}
{"nick":"ljharb","message":"spec year is just the very imperfect way eslint is currently configured","date":"2019-01-14T07:14:07.982Z","type":"message"}
{"nick":"Bakkot","message":"why is the parser the correct way to configure that?","date":"2019-01-14T07:14:14.528Z","type":"message"}
{"nick":"ljharb","message":"because the targets have parsers?","date":"2019-01-14T07:14:20.834Z","type":"message"}
{"nick":"Bakkot","message":"so? targets have interpreters too. so does eslint, in an abstract sense.","date":"2019-01-14T07:14:35.168Z","type":"message"}
{"nick":"ljharb","message":"so \"what can parse\" should be the overlap of what will parse on every target","date":"2019-01-14T07:14:46.504Z","type":"message"}
{"nick":"Bakkot","message":"the way you configure eslint's interpreter is with _rules_","date":"2019-01-14T07:14:48.270Z","type":"message"}
{"nick":"ljharb","message":"the rules only get the chance to work if it parses","date":"2019-01-14T07:15:00.704Z","type":"message"}
{"nick":"Bakkot","message":"right!","date":"2019-01-14T07:15:04.633Z","type":"message"}
{"nick":"Bakkot","message":"so it should parse as many things as it can!","date":"2019-01-14T07:15:08.404Z","type":"message"}
{"nick":"Bakkot","message":"so the rules get a chance to work!","date":"2019-01-14T07:15:11.900Z","type":"message"}
{"nick":"Bakkot","message":"since the point of eslint is to run the rules!","date":"2019-01-14T07:15:17.857Z","type":"message"}
{"nick":"ljharb","message":"no, i'm saying the rules don't matter if the code won't parse on your targets","date":"2019-01-14T07:15:22.440Z","type":"message"}
{"nick":"Bakkot","message":"the parsing doesn't matter if the code won't run correctly on your targets because of a semantics issue which a rule would have caught.","date":"2019-01-14T07:15:47.280Z","type":"message"}
{"nick":"Bakkot","message":"there is not meaningful difference between \"wrong because it will fail to parse on your target\" and \"wrong because of other correctness issues of the type caught by rules\"","date":"2019-01-14T07:16:12.223Z","type":"message"}
{"nick":"ljharb","message":"ok, perhaps","date":"2019-01-14T07:16:19.408Z","type":"message"}
{"nick":"ljharb","message":"but then the rules related to \"what works on your targets\" should be enabled by default :-)","date":"2019-01-14T07:16:33.031Z","type":"message"}
{"nick":"Bakkot","message":"my preference would be for no rules to be enabled by default, which means the same thing for all users, whereas \"what works on your targets\" does not mean the same thing for most pairs of users.","date":"2019-01-14T07:17:32.548Z","type":"message"}
{"nick":"Bakkot","message":"but sure, I am fine with that, as long as it parses those programs.","date":"2019-01-14T07:17:59.649Z","type":"message"}
{"nick":"Bakkot","message":"(anyway, point is, I continue to think it's reasonable for parsers to only support es-latest and optionally extensions, in most cases)","date":"2019-01-14T07:20:32.493Z","type":"message"}
{"nick":"Bakkot","message":"(I guess \"error on all programs, because someone might not have javascript\" might actually be a reasonable default too; it means the same thing for everyone and would at least get the point across that you will need to think about and configure which downstream use cases you care to support)","date":"2019-01-14T07:22:36.665Z","type":"message"}
{"nick":"ljharb","message":"lol, i'd be fine with that if it forced everyone to provide targets, and included whatever kind of default-on enforcement to prevent code that won't run on them","date":"2019-01-14T07:25:12.323Z","type":"message"}
{"nick":"howdoi","date":"2019-01-14T09:13:53.726Z","type":"join"}
{"nick":"mgol","date":"2019-01-14T10:08:48.431Z","type":"join"}
{"nick":"keith_miller","date":"2019-01-14T11:44:54.432Z","type":"join"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T11:55:01.932Z","type":"quit"}
{"nick":"gibson042","date":"2019-01-14T13:25:45.112Z","type":"join"}
{"nick":"jmdyck","date":"2019-01-14T13:39:04.907Z","type":"join"}
{"nick":"gibson042","reason":"Ping timeout: 258 seconds","date":"2019-01-14T14:28:06.150Z","type":"quit"}
{"nick":"bradleymeck","message":"Bakkot: when doing static analysis I try to go for loosest mode with most common syntax extensions. if you force people to use the compiled form you get into weird renaming issues while showing them sources","date":"2019-01-14T14:39:53.308Z","type":"message"}
{"nick":"gibson042","date":"2019-01-14T14:41:46.880Z","type":"join"}
{"nick":"bradleymeck","message":"who was going to propose freezePrototype?","date":"2019-01-14T14:55:28.124Z","type":"message"}
{"nick":"bradleymeck","message":"nm XD","date":"2019-01-14T14:58:14.231Z","type":"message"}
{"nick":"keith_miller","date":"2019-01-14T15:42:23.326Z","type":"join"}
{"nick":"jmdyck","reason":"Ping timeout: 250 seconds","date":"2019-01-14T16:14:26.892Z","type":"quit"}
{"nick":"jmdyck","date":"2019-01-14T16:16:15.135Z","type":"join"}
{"nick":"cloudshu","date":"2019-01-14T16:37:21.897Z","type":"join"}
{"nick":"howdoi","reason":"Quit: Connection closed for inactivity","date":"2019-01-14T17:13:41.215Z","type":"quit"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T17:19:43.586Z","type":"quit"}
{"nick":"keith_miller","date":"2019-01-14T17:35:57.270Z","type":"join"}
{"nick":"AtumT","date":"2019-01-14T17:43:40.151Z","type":"join"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T18:58:12.148Z","type":"quit"}
{"nick":"rkirsling","message":"littledan: did these questions of yours ever get answered? https://github.com/tc39/test262/pull/688#issuecomment-311759747","date":"2019-01-14T18:59:10.902Z","type":"message"}
{"nick":"rkirsling","message":"I found the expected behavior here a little surprising: https://test262.report/browse/language/expressions/new/non-ctor-err-realm.js","date":"2019-01-14T18:59:34.492Z","type":"message"}
{"nick":"littledan","message":"I don't see any answers there","date":"2019-01-14T18:59:39.828Z","type":"message"}
{"nick":"littledan","message":"realm stuff is all a little surprisng","date":"2019-01-14T18:59:57.892Z","type":"message"}
{"nick":"rkirsling","message":"yeah","date":"2019-01-14T19:00:24.181Z","type":"message"}
{"nick":"keith_miller","date":"2019-01-14T19:02:56.913Z","type":"join"}
{"nick":"keith_miller","reason":"Client Quit","date":"2019-01-14T19:06:30.843Z","type":"quit"}
{"nick":"howdoi","date":"2019-01-14T19:06:36.039Z","type":"join"}
{"nick":"keith_miller","date":"2019-01-14T19:08:41.865Z","type":"join"}
{"nick":"mgol","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T19:10:38.858Z","type":"quit"}
{"nick":"littledan","message":"BTW, should we set up some place that, when people want to write about TC39 ,they can send their blog post or slide deck to us for review and corrections, if they want?","date":"2019-01-14T19:22:58.922Z","type":"message"}
{"nick":"littledan","message":"this could help keep public information correct","date":"2019-01-14T19:23:13.843Z","type":"message"}
{"nick":"littledan","message":"(though it's been pretty good lately even without coordination)","date":"2019-01-14T19:23:44.186Z","type":"message"}
{"nick":"Bakkot","message":"how-we-work might be enough on its own? though I guess that's a little more internal-facing","date":"2019-01-14T19:25:50.724Z","type":"message"}
{"nick":"efaust","message":"littledan: do you get the sense that there's a broad demand for this kind of interaction?","date":"2019-01-14T19:31:43.122Z","type":"message"}
{"nick":"littledan","message":"this is a little different from how-we-work","date":"2019-01-14T19:32:40.216Z","type":"message"}
{"nick":"littledan","message":"I'm talking about reviewing the content, not our working practices","date":"2019-01-14T19:32:56.358Z","type":"message"}
{"nick":"littledan","message":"efaust: I'm in contact with a number of people who blog or give talks about TC39, and I sometimes review their work before it goes out, or put them in touch with proposal champions who do so. Formal channels could help distribute the load in the group and let more content creators have this kind of access, if we want to give it","date":"2019-01-14T19:33:58.577Z","type":"message"}
{"nick":"littledan","message":"I don't think it's like everyone who does that stuff should be expected to get our sign-off, just like a possible way we could make ourselves available as a resource","date":"2019-01-14T19:34:42.776Z","type":"message"}
{"nick":"efaust","message":"oh, I didn't think you were proposing a watchdog :P","date":"2019-01-14T19:38:20.315Z","type":"message"}
{"nick":"akirose","date":"2019-01-14T19:44:50.877Z","type":"join"}
{"nick":"Domenic","message":"So I'm starting to see the need for a fairly common operation which goes async iterator -> promise<array>, similar to how `Array.from(i)` or `[...i]` works on sync iterators","date":"2019-01-14T19:57:34.372Z","type":"message"}
{"nick":"Domenic","message":"If we were to standardize this, the best spelling I can think of is `ai.collect()`; there's no `XXX.from(ai)` or `[...await... i]` syntax that makes sense","date":"2019-01-14T19:58:47.272Z","type":"message"}
{"nick":"Domenic","message":"This naturally raises the question as to whether we should add `i.collect()` to `Iterator.prototype` as well, because two ways to do something is not enough :-/.","date":"2019-01-14T19:59:48.556Z","type":"message"}
{"nick":"Domenic","message":"Anyone have thoughts, either on spelling, or want to be a champion for this?","date":"2019-01-14T19:59:51.173Z","type":"message"}
{"nick":"Bakkot","message":"I feel like `Promise.all` could be adapted to work there?","date":"2019-01-14T20:00:07.999Z","type":"message"}
{"nick":"Domenic","message":"Hmm how so?","date":"2019-01-14T20:00:26.287Z","type":"message"}
{"nick":"Bakkot","message":"it could have a branch for when Symbol.asyncIterator is present on its argument which did the logic you wanted there","date":"2019-01-14T20:01:07.309Z","type":"message"}
{"nick":"Bakkot","message":"disclaimer: have not thought about this for more than five seconds","date":"2019-01-14T20:01:17.507Z","type":"message"}
{"nick":"zenparsing","message":"an \"itertools\" standard lib of some is needed for different iterator operations. I was hopeful that it could be an std module.","date":"2019-01-14T20:01:26.815Z","type":"message"}
{"nick":"zenparsing","message":"(of some kind)","date":"2019-01-14T20:02:00.109Z","type":"message"}
{"nick":"Domenic","message":"Bakkot: ah interesting, I'm not sure I'd want to overload `Promise.all()` in that way, but it vaguely rhymes.","date":"2019-01-14T20:02:14.213Z","type":"message"}
{"nick":"Bakkot","message":"that is, I am proposing that `Promise.all(asyncIterator)` could be an overload which would return a promise for an array, the same way `Promise.all(syncIterator)` currently does","date":"2019-01-14T20:02:18.365Z","type":"message"}
{"nick":"Domenic","message":"I guess the return types are indeed the same.","date":"2019-01-14T20:02:37.273Z","type":"message"}
{"nick":"littledan","message":"zenparsing: +1","date":"2019-01-14T20:03:14.212Z","type":"message"}
{"nick":"Domenic","message":"zenparsing: I feel like `[Async]Iterator.prototype` is underused, personally.","date":"2019-01-14T20:03:15.727Z","type":"message"}
{"nick":"littledan","message":"zenparsing: I've been hoping that for a while. I'm excited to see built-in modules moving along","date":"2019-01-14T20:03:34.572Z","type":"message"}
{"nick":"Domenic","message":"We went to all the trouble to wire it up, if we're going to add iterator utilities anywhere, it should be there, IMO.","date":"2019-01-14T20:03:49.680Z","type":"message"}
{"nick":"littledan","message":"there have been various proposals to use Iterator.prototype, but they haven't moved along. Does anyone know whether there were real objections to using it?","date":"2019-01-14T20:03:58.951Z","type":"message"}
{"nick":"Domenic","message":"I think it's just complicated.","date":"2019-01-14T20:04:22.453Z","type":"message"}
{"nick":"Domenic","message":"Especially if you want to do the proper thing where `iterator.filter(...).map(...).reduce(...)` only does one iteration in total.","date":"2019-01-14T20:05:01.357Z","type":"message"}
{"nick":"Bakkot","message":"IIRC the main problem was lack of a broadly agreed upon vision of where things belong - stdlib, on the containers themselves, on the container-specific iterators, on the iterator prototype","date":"2019-01-14T20:05:04.087Z","type":"message"}
{"nick":"Domenic","message":"Containers themselves always need some methods; it's more ergonomic than going container -> generic iterator stuff -> back to container. I do remember that discussion.","date":"2019-01-14T20:05:38.335Z","type":"message"}
{"nick":"mgol","date":"2019-01-14T20:06:00.892Z","type":"join"}
{"nick":"Domenic","message":"But between itertools functions and Iterator.prototype methods, I'm not sure we really had that discussion.","date":"2019-01-14T20:06:04.221Z","type":"message"}
{"nick":"zenparsing","message":"one advantage of itertools is that I don't have to subclass Iterator for users to get the goodies","date":"2019-01-14T20:07:14.789Z","type":"message"}
{"nick":"zenparsing","message":"(or require them to do Iterator.from or somesuch)","date":"2019-01-14T20:07:48.749Z","type":"message"}
{"nick":"Bakkot","message":"+1","date":"2019-01-14T20:07:58.956Z","type":"message"}
{"nick":"Domenic","message":"Who is writing custom iterators?","date":"2019-01-14T20:09:23.373Z","type":"message"}
{"nick":"Domenic","message":"If people are doing that, I agree it sucks today, because we for some reason didn't make Iterator global.","date":"2019-01-14T20:09:43.388Z","type":"message"}
{"nick":"Bakkot","message":"generators? though I forget how that prototype chain works","date":"2019-01-14T20:09:50.285Z","type":"message"}
{"nick":"Domenic","message":"Nah those inherit","date":"2019-01-14T20:09:59.808Z","type":"message"}
{"nick":"devsnek","message":"i really want a global iterator object","date":"2019-01-14T20:10:11.782Z","type":"message"}
{"nick":"devsnek","message":"like Math","date":"2019-01-14T20:10:15.129Z","type":"message"}
{"nick":"Domenic","message":"https://chromium-review.googlesource.com/c/chromium/src/+/1396453/3/third_party/blink/renderer/core/script/resources/layered_api/kv-storage/async_iterator.js#13 is pretty ridiculous, but as long as it's only platform code having to do it, I'm not too mad.","date":"2019-01-14T20:10:33.501Z","type":"message"}
{"nick":"devsnek","message":"and i want Iterator.prototype and Iterator.asyncPrototype","date":"2019-01-14T20:10:59.948Z","type":"message"}
{"nick":"Domenic","message":"Oh right, there is no actual Iterator constructor, so it'd have to be a namespace.","date":"2019-01-14T20:11:50.041Z","type":"message"}
{"nick":"devsnek","message":"yeah like Math","date":"2019-01-14T20:11:54.965Z","type":"message"}
{"nick":"devsnek","message":"i had a gist somewhere","date":"2019-01-14T20:12:02.648Z","type":"message"}
{"nick":"devsnek","message":"here we go https://gist.github.com/devsnek/230919934eff442a31f9e3116a752c68","date":"2019-01-14T20:12:17.815Z","type":"message"}
{"nick":"Domenic","message":"Those are nice but they miss doing the proper thing where `iterator.filter(...).map(...).reduce(...)` only does one iteration in total.","date":"2019-01-14T20:12:55.898Z","type":"message"}
{"nick":"devsnek","message":"huh","date":"2019-01-14T20:13:11.572Z","type":"message"}
{"nick":"devsnek","message":"they each return another iterator","date":"2019-01-14T20:13:17.199Z","type":"message"}
{"nick":"devsnek","message":"except for collect","date":"2019-01-14T20:13:25.893Z","type":"message"}
{"nick":"devsnek","message":"the last `.next()` would turn each item in the chain once","date":"2019-01-14T20:13:45.914Z","type":"message"}
{"nick":"Domenic","message":"Hmm you may be right","date":"2019-01-14T20:13:48.114Z","type":"message"}
{"nick":"Bakkot","message":"what do you mean by \"only does one iteration total\"?","date":"2019-01-14T20:13:53.196Z","type":"message"}
{"nick":"devsnek","message":"like the chain should be lazy","date":"2019-01-14T20:14:03.340Z","type":"message"}
{"nick":"Bakkot","message":"it looks like they would work for an iterator which could only be iterated once","date":"2019-01-14T20:14:04.645Z","type":"message"}
{"nick":"Domenic","message":"I remember reading an implementation of C# LINQ that did something of that sort and I remember it being complicated. So I assumed something simple like that would not be enough.","date":"2019-01-14T20:14:23.827Z","type":"message"}
{"nick":"devsnek","message":"everything is simple in js :)","date":"2019-01-14T20:14:37.918Z","type":"message"}
{"nick":"Domenic","message":"I am now going to re-read that C# thing to see if maybe it was simpler than I thought.","date":"2019-01-14T20:14:38.427Z","type":"message"}
{"nick":"devsnek","message":"link the c# thing","date":"2019-01-14T20:14:46.623Z","type":"message"}
{"nick":"Bakkot","message":"also I recall seeing a library somewhere which provided similar utils, but have lost the link","date":"2019-01-14T20:15:08.408Z","type":"message"}
{"nick":"devsnek","message":"itertools","date":"2019-01-14T20:15:15.223Z","type":"message"}
{"nick":"devsnek","message":"https://www.npmjs.com/package/itertools","date":"2019-01-14T20:15:29.550Z","type":"message"}
{"nick":"devsnek","message":"itertools is more focused on array-likes though","date":"2019-01-14T20:15:37.035Z","type":"message"}
{"nick":"devsnek","message":"since it existed before the iterator protocol","date":"2019-01-14T20:15:48.957Z","type":"message"}
{"nick":"Domenic","message":"Ah no it's fine","date":"2019-01-14T20:16:07.040Z","type":"message"}
{"nick":"Domenic","message":"It's complicated for LINQ to SQL","date":"2019-01-14T20:16:10.936Z","type":"message"}
{"nick":"devsnek","message":"lol","date":"2019-01-14T20:16:20.070Z","type":"message"}
{"nick":"Domenic","message":"But it's simple for LINQ to objects (which is what we're discussing)","date":"2019-01-14T20:16:23.536Z","type":"message"}
{"nick":"littledan","message":"<small>the pipeline operator might make itertools as a module more attractive</small>","date":"2019-01-14T20:16:29.383Z","type":"message"}
{"nick":"devsnek","message":"if we get pipeline or call bind synax","date":"2019-01-14T20:16:42.471Z","type":"message"}
{"nick":"devsnek","message":"Iterator.map and such would be cool","date":"2019-01-14T20:16:52.999Z","type":"message"}
{"nick":"Domenic","message":"LINQ to SQL needs to basically build up a graph of operations as you call them and then at the serialization-to-SQL step convert it into a SQL query. Which involves lots of intermediate state tracking.","date":"2019-01-14T20:16:55.462Z","type":"message"}
{"nick":"devsnek","message":"or on the prototype","date":"2019-01-14T20:16:57.924Z","type":"message"}
{"nick":"devsnek","message":"bind syntax is a weird feature","date":"2019-01-14T20:17:02.300Z","type":"message"}
{"nick":"Domenic","message":"Yeah putting them on the prototype allows us to put off the pipeline operator longer ;)","date":"2019-01-14T20:17:14.055Z","type":"message"}
{"nick":"devsnek","message":"lol","date":"2019-01-14T20:17:18.892Z","type":"message"}
{"nick":"Bakkot","message":"prototype definitely seems like the right place for most of these, if possible","date":"2019-01-14T20:17:21.722Z","type":"message"}
{"nick":"devsnek","message":"but the lodash users will be angry","date":"2019-01-14T20:17:31.192Z","type":"message"}
{"nick":"Domenic","message":"https://gist.github.com/devsnek/230919934eff442a31f9e3116a752c68 seems like a good start, someone should champion that.","date":"2019-01-14T20:18:00.514Z","type":"message"}
{"nick":"Domenic","message":"devsnek do you have time to write a formal spec if I do the committee presentation work?","date":"2019-01-14T20:18:17.968Z","type":"message"}
{"nick":"devsnek","message":"sure","date":"2019-01-14T20:18:23.585Z","type":"message"}
{"nick":"littledan","message":"(I think the pipeline operator is justified even if we don't have anything in the standard library that's defined for it)","date":"2019-01-14T20:18:38.876Z","type":"message"}
{"nick":"devsnek","message":"if i get that internship i could even present it myself 🤷‍♂️","date":"2019-01-14T20:18:41.630Z","type":"message"}
{"nick":"Domenic","message":"Indeed!","date":"2019-01-14T20:18:47.816Z","type":"message"}
{"nick":"Domenic","message":"Well, when you have a repo that you feel is stage 1 worthy (i.e. a nice README) let me know and I'll put something on the agenda of whatever meeting is next.","date":"2019-01-14T20:19:14.134Z","type":"message"}
{"nick":"devsnek","message":"i'll put it on my todo list","date":"2019-01-14T20:19:23.901Z","type":"message"}
{"nick":"devsnek","message":"well its been on my todo list","date":"2019-01-14T20:19:30.959Z","type":"message"}
{"nick":"zenparsing","message":"littledan: the nice thing about \"elixer-style\" (first arg passing) is that you don't need to write a lib specifically for it","date":"2019-01-14T20:19:32.605Z","type":"message"}
{"nick":"devsnek","message":"but writing iterator stuff without generator syntax is annoying and i keep putting it off","date":"2019-01-14T20:19:44.594Z","type":"message"}
{"nick":"Domenic","message":"Yeah... the formal spec will be annoying","date":"2019-01-14T20:20:10.437Z","type":"message"}
{"nick":"devsnek","message":"if we can write \"let x be Await(y)\" why can't we write \"let x be Yield(y)\"","date":"2019-01-14T20:20:16.928Z","type":"message"}
{"nick":"Domenic","message":"The readme won't be too bad.","date":"2019-01-14T20:20:19.318Z","type":"message"}
{"nick":"littledan","message":"zenparsing: Right (to some extent--there's definitely already code written in a currying style that would work out of the box with F#)","date":"2019-01-14T20:20:29.486Z","type":"message"}
{"nick":"Domenic","message":"We might be able to introduce a Yield() macro, although every time I use the Await() macro I confuse myself, so :-/.","date":"2019-01-14T20:20:44.364Z","type":"message"}
{"nick":"littledan","message":"probably starting with a README with good docs and a polyfill would be good... we can compile it into spec text later","date":"2019-01-14T20:21:35.898Z","type":"message"}
{"nick":"devsnek","message":"is a proposal without a champion a 0 or a -1","date":"2019-01-14T20:22:55.573Z","type":"message"}
{"nick":"devsnek","message":"0 right","date":"2019-01-14T20:23:11.147Z","type":"message"}
{"nick":"Domenic","message":"0 is whatever you want it to be","date":"2019-01-14T20:23:19.876Z","type":"message"}
{"nick":"Domenic","message":"0 has no rules","date":"2019-01-14T20:23:27.842Z","type":"message"}
{"nick":"devsnek","message":"how about -0","date":"2019-01-14T20:23:48.261Z","type":"message"}
{"nick":"Bakkot","message":"re: an overload for Promise.all, it occurs to me that this might be a problem if anyone ever defines both Symbol.iterator and Symbol.asyncIterator, which guess I could conceive of. also couldn't obviously be extended to `Promise.race` or even `Promise.allSettled` I don't think.","date":"2019-01-14T20:26:11.654Z","type":"message"}
{"nick":"Bakkot","message":"I still like Promise.all as the place for that operation though.","date":"2019-01-14T20:26:26.008Z","type":"message"}
{"nick":"devsnek","message":"if you use both it just depends on the consumer","date":"2019-01-14T20:26:53.558Z","type":"message"}
{"nick":"devsnek","message":"GetIterator() with hint=async would try to grab asyncIterator first the fall back to AsyncFromSyncIterator","date":"2019-01-14T20:27:23.822Z","type":"message"}
{"nick":"Bakkot","message":"Promise.all should not fall back to AsyncFromSyncIterator","date":"2019-01-14T20:27:56.078Z","type":"message"}
{"nick":"Bakkot","message":"but yeah, it could be spec'd","date":"2019-01-14T20:28:03.732Z","type":"message"}
{"nick":"Bakkot","message":"I'm just concerned about surprise, especially because it could change the semantics of existing code","date":"2019-01-14T20:28:17.325Z","type":"message"}
{"nick":"Domenic","message":"Hmmm but if it did would the behavior be equivalent? If so that would be a powerful hint that this is really one unified operation.","date":"2019-01-14T20:28:18.564Z","type":"message"}
{"nick":"Domenic","message":"I mean I guess the answer is yes.","date":"2019-01-14T20:28:25.939Z","type":"message"}
{"nick":"Bakkot","message":"hm, yeah, I guess Promise.all's early throwing makes that work","date":"2019-01-14T20:29:08.003Z","type":"message"}
{"nick":"devsnek","message":"why couldn't it using normal iterator handling","date":"2019-01-14T20:30:04.023Z","type":"message"}
{"nick":"devsnek","message":"that would make it easy to also include the existing behaviour of taking an array","date":"2019-01-14T20:30:15.888Z","type":"message"}
{"nick":"Domenic","message":"We would branch and fall back to existing behavior, for speed/observability if nothing else","date":"2019-01-14T20:30:29.161Z","type":"message"}
{"nick":"Bakkot","message":"I do not understand the question","date":"2019-01-14T20:30:29.315Z","type":"message"}
{"nick":"Domenic","message":"But it's nice to know that if we defined Promise.all() as operating primarily on async iterators, with async-from-sync-iterator fallback, it would behave basically the same as today's Promise.all()","date":"2019-01-14T20:30:57.043Z","type":"message"}
{"nick":"Domenic","message":"(Probably with like 3x as many .then() accesses and intermediate objects being the difference.)","date":"2019-01-14T20:31:18.642Z","type":"message"}
{"nick":"devsnek","message":"lol","date":"2019-01-14T20:31:22.703Z","type":"message"}
{"nick":"devsnek","message":"you can just JIT all that away right :P","date":"2019-01-14T20:31:40.112Z","type":"message"}
{"nick":"littledan","message":"turns out you can't just JIT everything away","date":"2019-01-14T20:43:30.623Z","type":"message"}
{"nick":"littledan","message":"optimizing everything when it's subclassable ends up leading to some pretty bad performance cliffs","date":"2019-01-14T20:43:52.889Z","type":"message"}
{"nick":"littledan","message":"or, depending how you cut it, maybe it'll work sometimes, and still unreliably, and only after the program was running for a while. But turns out that a lot of the execution time is the first time, or the first few times","date":"2019-01-14T20:45:10.587Z","type":"message"}
{"nick":"littledan","message":"Promise.all has improved a bunch in V8, but the most thorough way to do these things is to reserve for the situations where it's really really useful the design of everything being subclassable and having the methods in the subclasses be invoked","date":"2019-01-14T20:46:39.863Z","type":"message"}
{"nick":"littledan","message":"remember, we just made a change to async/await which was all about removing an intermediate Promise (\"shouldn't the JIT be able to eliminate it?\")","date":"2019-01-14T20:47:04.154Z","type":"message"}
{"nick":"Domenic","message":"Indeed, I'd hoped we learned our lesson about over-genericism and subclassability, but all the recent discussions on `Set` methods makes me think we have not :(","date":"2019-01-14T20:56:25.615Z","type":"message"}
{"nick":"nomadtechie_","date":"2019-01-14T21:04:15.887Z","type":"join"}
{"nick":"rkirsling_","date":"2019-01-14T21:04:37.762Z","type":"join"}
{"nick":"zenparsing_","date":"2019-01-14T21:04:49.766Z","type":"join"}
{"nick":"samth_","date":"2019-01-14T21:04:54.819Z","type":"join"}
{"nick":"littledan","message":"yep :(","date":"2019-01-14T21:06:32.573Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: for the set methods the generality is generally restricted to places where it won't hurt performance for the common case, which I think is the right approach","date":"2019-01-14T21:07:28.493Z","type":"message"}
{"nick":"Bakkot","message":"with the exception of using Symbol.species, I guess","date":"2019-01-14T21:07:48.204Z","type":"message"}
{"nick":"annevk_","date":"2019-01-14T21:07:56.877Z","type":"join"}
{"nick":"ystartsev_","date":"2019-01-14T21:08:34.905Z","type":"join"}
{"nick":"Domenic","message":"It's hurting the complexity of the methods' mental models, regardless as to whether they're theoretically common-case optimizable.","date":"2019-01-14T21:09:24.481Z","type":"message"}
{"nick":"rkirsling","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:38.317Z","type":"quit"}
{"nick":"annevk","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:39.570Z","type":"quit"}
{"nick":"nomadtechie","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:39.736Z","type":"quit"}
{"nick":"saulh[m]","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:43.255Z","type":"quit"}
{"nick":"ystartsev","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:43.626Z","type":"quit"}
{"nick":"samth","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:43.780Z","type":"quit"}
{"nick":"zenparsing","reason":"Ping timeout: 268 seconds","date":"2019-01-14T21:11:45.127Z","type":"quit"}
{"nick":"rkirsling_","new_nick":"rkirsling","date":"2019-01-14T21:11:45.434Z","type":"nick"}
{"nick":"annevk_","new_nick":"annevk","date":"2019-01-14T21:11:45.588Z","type":"nick"}
{"nick":"samth_","new_nick":"samth","date":"2019-01-14T21:11:45.588Z","type":"nick"}
{"nick":"ystartsev_","new_nick":"ystartsev","date":"2019-01-14T21:11:45.742Z","type":"nick"}
{"nick":"Bakkot","message":"I have the exact opposite intuition, I guess","date":"2019-01-14T21:12:06.058Z","type":"message"}
{"nick":"Bakkot","message":"well, making isSubsetOf take an iterable hurts the complexity of its mental model, I suppose","date":"2019-01-14T21:12:17.696Z","type":"message"}
{"nick":"saulh[m]","date":"2019-01-14T21:13:18.777Z","type":"join"}
{"nick":"Bakkot","message":"otherwise my mental model is \"isSubsetOf needs to iterate its receiver and query membership in its argument, isSupersetOf needs to iterate its argument and query membership in its receiver\", etc, and want all the methods to do those things in ways consistent with each other and without big-O cliffs for well-behaved subclasses","date":"2019-01-14T21:13:33.975Z","type":"message"}
{"nick":"devsnek","message":"Domenic: threw this together during lunch https://github.com/devsnek/proposal-iterator-helpers","date":"2019-01-14T21:26:01.013Z","type":"message"}
{"nick":"Domenic","message":"My intuition is that the simple thing is that set methods operate on Sets using SetData","date":"2019-01-14T21:26:29.209Z","type":"message"}
{"nick":"ljharb","message":"Domenic: would your intuition be harmed if, lacking SetData, it constructed a Set on which to operate?","date":"2019-01-14T21:26:54.344Z","type":"message"}
{"nick":"Domenic","message":"Yeah","date":"2019-01-14T21:27:00.358Z","type":"message"}
{"nick":"Domenic","message":"Just take Sets. If it's not a Set, then TypeError, oh well.","date":"2019-01-14T21:27:21.862Z","type":"message"}
{"nick":"ljharb","message":"so you'd prefer the explicit `set.someOp(new Set(iterable))`","date":"2019-01-14T21:27:25.263Z","type":"message"}
{"nick":"Domenic","message":"Indeed.","date":"2019-01-14T21:27:31.056Z","type":"message"}
{"nick":"Domenic","message":"devsnek: this is pretty solid, hmm. Maybe I'll dial in to try to present this at the next meeting.","date":"2019-01-14T21:28:32.405Z","type":"message"}
{"nick":"Bakkot","message":"Domenic: funnily enough, the argument against that was that the explicit pattern would be too hard to optimize","date":"2019-01-14T21:29:17.427Z","type":"message"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T21:31:16.996Z","type":"quit"}
{"nick":"zenparsing_","date":"2019-01-14T21:32:54.810Z","type":"quit"}
{"nick":"zenparsing_","date":"2019-01-14T21:33:14.681Z","type":"join"}
{"nick":"zenparsing_","reason":"Client Quit","date":"2019-01-14T21:33:55.861Z","type":"quit"}
{"nick":"zenparsing","date":"2019-01-14T21:34:38.914Z","type":"join"}
{"nick":"Domenic","message":"devsnek: https://github.com/tc39/agendas/commit/081bcf2b63d01bc60688ca2b9c860db9bb361c4f","date":"2019-01-14T21:48:24.234Z","type":"message"}
{"nick":"devsnek","message":"woo","date":"2019-01-14T21:57:51.763Z","type":"message"}
{"nick":"gsathya","message":"Bakkot, not too hard to optimize, but *harder* to optimize for the baseline","date":"2019-01-14T21:58:15.423Z","type":"message"}
{"nick":"TabAtkins","message":"I'm not in favor of the \"explicit pattern\". I do enough work with Sets in Python that I already have my fingers trained to use the methods rather than the operators, specifically because the methods will convert iterables while the operators strictly require both args to be sets.","date":"2019-01-14T21:58:53.163Z","type":"message"}
{"nick":"TabAtkins","message":"Like, use SetData if you receive a Set, sure, but allow iterables too, as its' good for ergonomics. I don't think the extra `new Set(...)` adds any meaningful safety or readability signals to the code.","date":"2019-01-14T22:00:06.723Z","type":"message"}
{"nick":"TabAtkins","message":"(It also means that I'll naturally want to instead provide a wrapper function that either returns its arg if it's a Set or constructs a Set from it, so I'm not causing extra object churn for no reason.)","date":"2019-01-14T22:00:54.030Z","type":"message"}
{"nick":"keith_miller","date":"2019-01-14T22:01:30.233Z","type":"join"}
{"nick":"Bakkot","message":"If you're going to accept an iterable, though, you do need to short-circuit once you have enough to answer your question, like `.every` etc","date":"2019-01-14T22:03:23.202Z","type":"message"}
{"nick":"ljharb","message":"not necessarily - if you constructed a set with it, you'd exhaust the iterable first, and then operate on SetData","date":"2019-01-14T22:04:15.989Z","type":"message"}
{"nick":"Bakkot","message":"right, and that would be wrong","date":"2019-01-14T22:04:21.999Z","type":"message"}
{"nick":"Bakkot","message":"that is, the wrong thing for a method accepting an iterable to do","date":"2019-01-14T22:04:31.086Z","type":"message"}
{"nick":"ljharb","message":"that's what Array.from does?","date":"2019-01-14T22:04:48.804Z","type":"message"}
{"nick":"Bakkot","message":"Array.from can't short-circuit, surely?","date":"2019-01-14T22:05:07.583Z","type":"message"}
{"nick":"ljharb","message":"oh sure, that's true","date":"2019-01-14T22:05:11.507Z","type":"message"}
{"nick":"ljharb","message":"but short-circuiting is an implementation detail","date":"2019-01-14T22:05:17.318Z","type":"message"}
{"nick":"Bakkot","message":"no, it's not","date":"2019-01-14T22:05:30.747Z","type":"message"}
{"nick":"Bakkot","message":"it critically affects performance in many cases","date":"2019-01-14T22:05:39.644Z","type":"message"}
{"nick":"ljharb","message":"like it's true that `.some` short circuits, but conceptually it's answering the question \"do any of these items pass the predicate\"","date":"2019-01-14T22:05:43.147Z","type":"message"}
{"nick":"Bakkot","message":"yeah, but if it answered that question without short-circuiting, I would never use it or allow it to be used in codebases I maintained","date":"2019-01-14T22:07:18.332Z","type":"message"}
{"nick":"ljharb","message":"sure, but that's not the same thing as it being an intrinsic part of the conceptual operation","date":"2019-01-14T22:07:53.069Z","type":"message"}
{"nick":"gsathya","message":"given no monkey patching, the engine can just do this, right? why do we need to spec this early bailout?","date":"2019-01-14T22:09:14.896Z","type":"message"}
{"nick":"ljharb","message":"well, if we specced it like \"construct a set from the iterable\", it'd have to exhaust it, i think","date":"2019-01-14T22:09:50.307Z","type":"message"}
{"nick":"Bakkot","message":"lacking a definition for \"intrinsic part of the conceptual operation\", I can't really disagree, but I would be very surprised by the non-short-circuiting behavior","date":"2019-01-14T22:09:55.692Z","type":"message"}
{"nick":"ljharb","message":"noted","date":"2019-01-14T22:10:00.766Z","type":"message"}
{"nick":"Bakkot","message":"ljharb: if the engine can observe the no-monkey-patching, it can skip the whole affair and do whatever it wants, including early bailout","date":"2019-01-14T22:10:21.432Z","type":"message"}
{"nick":"gsathya","message":"ljharb, why?","date":"2019-01-14T22:10:24.544Z","type":"message"}
{"nick":"gsathya","message":"yeah","date":"2019-01-14T22:10:25.764Z","type":"message"}
{"nick":"gsathya","message":"what Bakkot said","date":"2019-01-14T22:10:32.868Z","type":"message"}
{"nick":"ljharb","message":"ohhhh right","date":"2019-01-14T22:10:40.994Z","type":"message"}
{"nick":"ljharb","message":"wait","date":"2019-01-14T22:10:47.581Z","type":"message"}
{"nick":"Bakkot","message":"gsathya: that is true in the case that you pass an array, but it should still be required to do the right thing if you pass it a more complicated iterable","date":"2019-01-14T22:11:00.026Z","type":"message"}
{"nick":"ljharb","message":"if it's internally specced to do `new Set(iterable)`, then there's no bailout possible","date":"2019-01-14T22:11:03.451Z","type":"message"}
{"nick":"ljharb","message":"for a non-monkeypatched array, or a Set, sure, but not for a generator","date":"2019-01-14T22:11:22.480Z","type":"message"}
{"nick":"Bakkot","message":"right, gsathya was talking specifically about the case of passing a non-monkeypatched array, I am pretty sure","date":"2019-01-14T22:11:37.092Z","type":"message"}
{"nick":"Bakkot","message":"(else I am also confused)","date":"2019-01-14T22:11:51.848Z","type":"message"}
{"nick":"Bakkot","message":"(sorry, I should let him speak for himself)","date":"2019-01-14T22:11:59.573Z","type":"message"}
{"nick":"gsathya","message":"yes, non monkey patched array is the common case (.. and that's what I care about the most)","date":"2019-01-14T22:12:15.785Z","type":"message"}
{"nick":"gsathya","message":"I don't think it's worthwhile to complicate the spec for making some very narrow use case slightly faster","date":"2019-01-14T22:12:20.217Z","type":"message"}
{"nick":"ljharb","message":"i mean, no matter what we're likely to do, \"sets\" and \"non monkeypatched arrays\" can be made to be fast, i assume","date":"2019-01-14T22:12:39.337Z","type":"message"}
{"nick":"Bakkot","message":"there's a lot of non-array iterables around, and short-circuiting is not just \"slightly\" faster in many cases","date":"2019-01-14T22:14:10.242Z","type":"message"}
{"nick":"gsathya","message":"if you have a non array iterable, then your perf is already shot","date":"2019-01-14T22:14:52.731Z","type":"message"}
{"nick":"Bakkot","message":"\"hits slower path\" is a very different kind of perf being shot than \"takes 1000 steps when 1 would have done\"","date":"2019-01-14T22:15:43.547Z","type":"message"}
{"nick":"ljharb","message":"gsathya: strings?","date":"2019-01-14T22:15:57.609Z","type":"message"}
{"nick":"gsathya","message":"ljharb, sure we can optimize that too; built in iterables can be optimized","date":"2019-01-14T22:17:24.911Z","type":"message"}
{"nick":"gsathya","message":"it's just the user defined ones that need to go through the whole iteration protocol dance","date":"2019-01-14T22:17:53.244Z","type":"message"}
{"nick":"ljharb","message":"gotcha","date":"2019-01-14T22:18:03.886Z","type":"message"}
{"nick":"gsathya","message":"Bakkot, not sure I agree but I don't have any data","date":"2019-01-14T22:20:01.657Z","type":"message"}
{"nick":"Bakkot","message":"I don't think data can answer this one? because in the cases engines can't optimize it would be, specifically, taking 1 step on the slow path vs taking 1000 steps on the slow path","date":"2019-01-14T22:21:51.206Z","type":"message"}
{"nick":"gsathya","message":"err, I meant generally comparing \"hits slower path\"","date":"2019-01-14T22:22:30.116Z","type":"message"}
{"nick":"gsathya","message":"if in general, \"hits slower path\" is going to dominate perf then this is a non issue","date":"2019-01-14T22:22:47.672Z","type":"message"}
{"nick":"Bakkot","message":"ah, understand","date":"2019-01-14T22:23:47.948Z","type":"message"}
{"nick":"Bakkot","message":"I dunno; I would guess that there's a lot of code which hits slow paths which still ends up perfectly reasonable in practice, but which would not if some operation on the critical path was an order of magnitude slower","date":"2019-01-14T22:25:57.357Z","type":"message"}
{"nick":"Bakkot","message":"that is to say, I think it's still worth caring about performance implications for code which hits slow paths, esp. when the slow path is as wide as \"any user-defined iterable\"","date":"2019-01-14T22:26:21.262Z","type":"message"}
{"nick":"gsathya","message":"I definitely agree that we should care about the slow paths (which is exactly why I'm focusing on the Array as an iterable case) but if you want everything to be fast, then nothing is","date":"2019-01-14T22:31:03.682Z","type":"message"}
{"nick":"gsathya","message":"(the fast path is when the argument is a Set, the rest are all slow-er paths)","date":"2019-01-14T22:32:04.056Z","type":"message"}
{"nick":"Bakkot","message":"If there's a reason specing the short-circuiting would actually slow down cases which the engine would otherwise have been able to optimize, that might be a good reason to give it up, but it doesn't seem like there ought to be?","date":"2019-01-14T22:35:25.924Z","type":"message"}
{"nick":"gsathya","message":"I think there's a lot of value in keeping the spec simple, especially when implementations try to optimize this. At this point, I don't think your changes will cause any of the optimizations I can think of to go away","date":"2019-01-14T22:43:35.943Z","type":"message"}
{"nick":"gsathya","message":"it blows my mind that a trivial isSubsetOf is going to be a page long spec","date":"2019-01-14T22:44:47.603Z","type":"message"}
{"nick":"TabAtkins","message":"Ain't nothing's trivial when everything's observable. ^_^","date":"2019-01-14T22:45:11.567Z","type":"message"}
{"nick":"TabAtkins","message":"(And when all observable aspects become depended-upon parts of the API contract.)","date":"2019-01-14T22:45:33.094Z","type":"message"}
{"nick":"gsathya","message":"good thing I'm giving up on all my proposals after this","date":"2019-01-14T22:46:43.736Z","type":"message"}
{"nick":"TabAtkins","message":"hahaha","date":"2019-01-14T22:48:10.446Z","type":"message"}
{"nick":"AtumT","reason":"Quit: AtumT","date":"2019-01-14T22:55:50.770Z","type":"quit"}
{"nick":"devsnek","message":"python lets you tee iterators 😓","date":"2019-01-14T23:02:55.670Z","type":"message"}
{"nick":"mgol","reason":"Ping timeout: 244 seconds","date":"2019-01-14T23:04:26.497Z","type":"quit"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T23:11:06.301Z","type":"quit"}
{"nick":"keith_miller","date":"2019-01-14T23:19:05.173Z","type":"join"}
{"nick":"mgol","date":"2019-01-14T23:22:49.629Z","type":"join"}
{"nick":"keith_miller","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T23:25:05.635Z","type":"quit"}
{"nick":"mgol","reason":"Quit: My MacBook has gone to sleep. ZZZzzz…","date":"2019-01-14T23:53:41.794Z","type":"quit"}
